{
  "openapi": "3.0.0",
  "info": {
    "title": "Answers API",
    "version": "2.0"
  },
  "servers": [
    {
      "url": "https://liveapi.yext.com/v2"
    }
  ],
  "paths": {
    "/accounts/{accountId}/answers/autocomplete": {
      "get": {
        "operationId": "autocomplete",
        "parameters": [
          {
            "$ref": "#/components/parameters/accountId"
          },
          {
            "$ref": "#/components/parameters/v"
          },
          {
            "$ref": "#/components/parameters/experienceKey"
          },
          {
            "$ref": "#/components/parameters/locale"
          },
          {
            "$ref": "#/components/parameters/autocompleteInput"
          }
        ],
        "summary": "Universal Search: Autocomplete",
        "description": "Retrieve a list of suggested queries across all verticals in the experience based on the characters already typed by the user. This API is meant to be hit after each keystroke.",
        "responses": {
          "200": {
            "$ref": "#/components/responses/AutocompleteResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/accounts/{accountId}/answers/query": {
      "get": {
        "operationId": "query",
        "parameters": [
          {
            "$ref": "#/components/parameters/accountId"
          },
          {
            "$ref": "#/components/parameters/v"
          },
          {
            "$ref": "#/components/parameters/experienceKey"
          },
          {
            "$ref": "#/components/parameters/queryLocale"
          },
          {
            "$ref": "#/components/parameters/requiredInput"
          },
          {
            "$ref": "#/components/parameters/location"
          },
          {
            "$ref": "#/components/parameters/session_id"
          },
          {
            "$ref": "#/components/parameters/universalLimit"
          },
          {
            "$ref": "#/components/parameters/queryTrigger"
          },
          {
            "$ref": "#/components/parameters/context"
          },
          {
            "$ref": "#/components/parameters/referrerPageUrl"
          },
          {
            "$ref": "#/components/parameters/skipSpellCheck"
          },
          {
            "$ref": "#/components/parameters/restrictVerticals"
          },
          {
            "$ref": "#/components/parameters/ignoreQueryRules"
          }
        ],
        "summary": "Universal Search: Query",
        "description": "Search for entities across all verticals within an answers experience.  Modules are returned for all verticals with relevant entities. Further fine tuning and filtering of the results can then be done using the vertical query endpoint.",
        "responses": {
          "200": {
            "$ref": "#/components/responses/UniversalQueryResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/accounts/{accountId}/answers/vertical/autocomplete": {
      "get": {
        "operationId": "verticalAutocomplete",
        "parameters": [
          {
            "$ref": "#/components/parameters/accountId"
          },
          {
            "$ref": "#/components/parameters/v"
          },
          {
            "$ref": "#/components/parameters/experienceKey"
          },
          {
            "$ref": "#/components/parameters/verticalKey"
          },
          {
            "$ref": "#/components/parameters/locale"
          },
          {
            "$ref": "#/components/parameters/autocompleteInput"
          }
        ],
        "summary": "Vertical Search: Autocomplete",
        "description": "Retrieve a list of suggested queries for the selected vertical based on the characters already typed by the user or the most popular queries when no user input is given.",
        "responses": {
          "200": {
            "$ref": "#/components/responses/AutocompleteResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/accounts/{accountId}/answers/vertical/query": {
      "get": {
        "operationId": "verticalQuery",
        "parameters": [
          {
            "$ref": "#/components/parameters/accountId"
          },
          {
            "$ref": "#/components/parameters/v"
          },
          {
            "$ref": "#/components/parameters/experienceKey"
          },
          {
            "$ref": "#/components/parameters/verticalKey"
          },
          {
            "$ref": "#/components/parameters/queryLocale"
          },
          {
            "$ref": "#/components/parameters/verticalInput"
          },
          {
            "$ref": "#/components/parameters/location"
          },
          {
            "$ref": "#/components/parameters/locationRadius"
          },
          {
            "$ref": "#/components/parameters/session_id"
          },
          {
            "$ref": "#/components/parameters/limit"
          },
          {
            "$ref": "#/components/parameters/offset"
          },
          {
            "$ref": "#/components/parameters/queryTrigger"
          },
          {
            "$ref": "#/components/parameters/context"
          },
          {
            "$ref": "#/components/parameters/referrerPageUrl"
          },
          {
            "$ref": "#/components/parameters/skipSpellCheck"
          },
          {
            "$ref": "#/components/parameters/Filters"
          },
          {
            "$ref": "#/components/parameters/FacetFilters"
          },
          {
            "$ref": "#/components/parameters/retrieveFacets"
          },
          {
            "$ref": "#/components/parameters/SortBys"
          },
          {
            "$ref": "#/components/parameters/ignoreQueryRules"
          }
        ],
        "summary": "Vertical Search: Query",
        "description": "Search for entities within the selected vertical.  Vertical query allows for fine tuning of the search using filters, facets and sorts passed in through the API.",
        "responses": {
          "200": {
            "$ref": "#/components/responses/VerticalQueryResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    },
    "/accounts/{accountId}/answers/filtersearch": {
      "get": {
        "operationId": "filtersearch",
        "parameters": [
          {
            "$ref": "#/components/parameters/accountId"
          },
          {
            "$ref": "#/components/parameters/v"
          },
          {
            "$ref": "#/components/parameters/experienceKey"
          },
          {
            "$ref": "#/components/parameters/locale"
          },
          {
            "$ref": "#/components/parameters/filterSearchVerticalKey"
          },
          {
            "$ref": "#/components/parameters/excluded"
          },
          {
            "$ref": "#/components/parameters/SearchParameters"
          },
          {
            "$ref": "#/components/parameters/requiredInput"
          }
        ],
        "summary": "Vertical Search: Filter Search",
        "description": "Retrieve a list of potential filters that match the user's input up to that point.  This differs from query suggest by only returning the names of filters that can be searched rather than the broader corpus of suggested queries.",
        "responses": {
          "200": {
            "$ref": "#/components/responses/FilterSearchResponse"
          },
          "400": {
            "$ref": "#/components/responses/ErrorResponse"
          }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "api_key": {
        "type": "apiKey",
        "name": "api_key",
        "in": "query"
      },
      "api-key": {
        "type": "apiKey",
        "name": "api-key",
        "in": "header"
      }
    },
    "parameters": {
      "accountId": {
        "name": "accountId",
        "in": "path",
        "required": true,
        "schema": {
          "type": "string"
        }
      },
      "v": {
        "name": "v",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "A date in `YYYYMMDD` format."
      },
      "experienceKey": {
        "name": "experienceKey",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "String key that uniquely identifies the answers experience."
      },
      "locale": {
        "name": "locale",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "The locale code of the experience (e.g. `en_GB`)."
      },
      "autocompleteInput": {
        "name": "input",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "The partial search term from the user."
      },
      "queryLocale": {
        "name": "locale",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "The locale code of the experience (e.g. `en_GB`). Only returns entities that have an entity profile associated with this locale."
      },
      "requiredInput": {
        "name": "input",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "The search term of the user."
      },
      "location": {
        "name": "location",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "The user's location as a comma separated latitude and longitude (e.g. `\"40.740957,-73.987565\"`)."
      },
      "session_id": {
        "name": "session_id",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "UUID used to track session state when cookies are blocked."
      },
      "universalLimit": {
        "name": "limit",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "JSON object specifying the limit for each vertical.  Each key is a vertical key and the value for each of those keys is a number 1-50 that denotes the limit for that vertical. This parameter should be provided as a URL-encoded string containing a JSON object."
      },
      "queryTrigger": {
        "name": "queryTrigger",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "String value that is logged to analytics denoting the trigger for the query.\nOptions include:\n* `suggest`, sent if the query is triggered from a spelling correction.\n* `initialize`, sent if the query is being triggered by a default initial search (in other words, the user did not enter query).\n"
      },
      "context": {
        "name": "context",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "Context is an arbitrary JSON object that is passed to query rules to be used for triggering rules as well as passing data to those rules. This parameter should be provided as a URL-encoded string containing a JSON object."
      },
      "referrerPageUrl": {
        "name": "referrerPageUrl",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "The URL of the webpage that directed to the page this request was made from."
      },
      "skipSpellCheck": {
        "name": "skipSpellCheck",
        "in": "query",
        "required": false,
        "schema": {
          "type": "boolean"
        },
        "description": "If true the query will skip spell checking."
      },
      "restrictVerticals": {
        "name": "restrictVerticals",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "A comma-separated list of verticals (e.g. `\"people,locations\"`). If specified, only results from these verticals will be returned."
      },
      "ignoreQueryRules": {
        "name": "ignoreQueryRules",
        "in": "query",
        "required": false,
        "schema": {
          "type": "boolean"
        },
        "description": "When set to true, ignores any Query Rules that would otherwise affect the results. Defaults to false."
      },
      "verticalKey": {
        "name": "verticalKey",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "String key that uniquely identifies the vertical."
      },
      "verticalInput": {
        "name": "input",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "The search term of the user."
      },
      "locationRadius": {
        "name": "locationRadius",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "Radius (in meters) that should be applied to any location filter that does not already have an explicit radius."
      },
      "limit": {
        "name": "limit",
        "in": "query",
        "schema": {
          "type": "integer",
          "default": 10,
          "maximum": 50
        },
        "description": "Number of results to return."
      },
      "offset": {
        "name": "offset",
        "in": "query",
        "required": false,
        "schema": {
          "type": "integer",
          "minimum": 0,
          "maximum": 9949,
          "default": 0
        },
        "description": "Number of results to skip. Used to move through results."
      },
      "Filters": {
        "name": "filters",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "This parameter represents one or more filtering conditions that are applied to the set of entities that would otherwise be returned. This parameter should be provided as a URL-encoded string containing a JSON object.\n\nFor example, if the filter JSON is `{\"name\":{\"$eq\":\"John\"}}`, then the filters param after URL-encoding will be: `filters=%7B%22name%22%3A%7B%22%24eq%22%3A%22John%22%7D%7D`\n\n**Basic Filter Structure**\n\nThe filter object at its core consists of a *matcher*, a *field*, and an *argument*.\n\nFor example, in the following filter JSON:\n\n```\n{\n  \"name\":{\n    \"$eq\":\"John\"\n  }\n}\n```\n\n`$eq` is the *matcher*, or filtering operation (equals, in this example),\n\n`name` is the *field* being filtered by, and\n\n`John` is *value* to be matched against.\n\n**Combining Multiple Filters**\n\nMultiple filters can be combined to form a conjunction (AND) of disjunctions (ORs) using the *combinators* `$and` and `$or`.  For example:\n```\n{\n  \"$and\": [\n    {\n      \"$or\": [\n        {\n          \"firstName\": {\n            \"$eq\": \"Jane\"\n          }\n        },\n        {\n          \"firstName\": {\n            \"$eq\": \"John\"\n          }\n        }\n      ]\n    },\n    {\n      \"lastName\": {\n        \"$eq\": \"Smith\"\n      }\n    }\n  ]\n}\n```\nAny filter that is the only item in its respective combinator may omit the combinator as is done with the lastName above.\n\n**Filter Negation**\n\nCertain filter types may be negated. For example:\n\n```\n{\n  \"$not\" {\n    \"name\":{\n      \"$eq\":\"John\"\n    }\n  }\n}\n```\n\nThis can also be written more simply with a `!` in the `$eq` parameter. The following filter would have the same effect:\n\n```\n{\n  \"name\":{\n    \"!$eq\":\"John\"\n  }\n}\n```\n\n**TEXT**\n\nThe `TEXT` filter type is supported for text fields. (e.g., **`name`**, **`countryCode`**)\n\n<table style=\"width:100%\">\n  <tr>\n    <th>Matcher</th>\n    <th>Details</th>\n  </tr>\n  <tr>\n    <th>$eq (equals)</th>\n    <th>\n\n    {\n      \"countryCode\":{\n        \"$eq\":\"US\"\n      }\n    },\n    {\n      \"countryCode\":{\n        \"!$eq\":\"US\"\n      }\n    }\n\n  Supports negation. Case insensitive.\n  </tr>\n  <tr>\n</table>\n\n**BOOLEAN**\n\n\nThe BOOLEAN filter type is supported for boolean fields and Yes / No custom fields.\n<table style=\"width:100%\">\n  <tr>\n    <th>Matcher</th>\n    <th>Details</th>\n  </tr>\n  <tr>\n    <th>$eq</th>\n    <th>\n\n    {\n      \"isFreeEvent\": {\n        \"$eq\": true\n      }\n    }\n\n  For booleans, the filter takes a boolean value, not a string.\n  Supports negation.\n  </tr>\n</table>\n\n**OPTION**\n\nThe OPTION filter type is supported for option custom fields and fields that have a predetermined list of valid values.\n\n *e.g., **`eventStatus`**, **`gender`**, `SINGLE_OPTION` and `MULTI_OPTION` types of custom fields.*\n\n<table style=\"width:100%\">\n  <tr>\n    <th>Matcher</th>\n    <th>Details</th>\n  </tr>\n  <tr>\n    <th>$eq</th>\n    <th>\n\n  Matching is case insensitive and insensitive to consecutive whitespace.\n\n  e.g., \"XYZ 123\" matches \"xyz       123\"\n\n    {\n      \"eventStatus\": {\n        \"$eq\": \"SCHEDULED\"\n      }\n    }\n</table>\n\n**INTEGER, FLOAT, DATE, DATETIME, and TIME**\n\nThese filter types are strictly ordered -- therefore, they support the following matchers:\n- Equals\n- Less Than / Less Than or Equal To\n- Greater Than / Greater Than or Equal To\n\n<table style=\"width:100%\">\n  <tr>\n    <th>Matcher</th>\n    <th>Details</th>\n  </tr>\n  <tr>\n    <th>$eq</th>\n    <th>\n\n  Equals\n\n    {\n      \"ageRange.maxValue\": {\n        \"$eq\": \"80\"\n      }\n    }\n\n  Supports negation.\n\n  </tr>\n  <tr>\n    <th>$lt</th>\n    <th>\n\n  Less than\n\n    {\n      \"time.start\": {\n        \"$lt\": \"2018-08-28T05:56\"\n      }\n    }\n\n  </tr>\n  <tr>\n    <th>$gt</th>\n    <th>\n\n  Greater than\n\n    {\n      \"ageRange.maxValue\": {\n        \"$gt\": \"50\"\n      }\n    }\n\n  </tr>\n  <tr>\n    <th>$le</th>\n    <th>\n\n  Less than or equal to\n\n    {\n      \"ageRange.maxValue\": {\n        \"$le\": \"40\"\n      }\n    }\n\n  </tr>\n  <tr>\n    <th>$ge</th>\n    <th>\n\n  Greater than or equal to\n\n    {\n      \"time.end\": {\n        \"$ge\":  \"2018-08-28T05:56\"\n      }\n    }\n\n  </tr>\n  <tr>\n    <th>$between</th>\n    <th>\n\n  An array that must contain exactly two elements with which the result is between.\n\n    {\n      \"time.end\": {\n        \"$between\":  [\"2018-08-28T05:56\", \"2018-08-29T05:56\"]\n      }\n    }\n\n  </tr>\n  <tr>\n    <th>Combinations</th>\n    <th>\n\n  In addition to between, it is possible to combine multiple matchers for a result similar to an \"and\" operation:\n\n    {\n      \"ageRange.maxValue\" : {\n        \"$gt\" : 10,\n        \"$lt\": 20\n      }\n    }\n\n  </tr>\n</table>\n"
      },
      "FacetFilters": {
        "name": "facetFilters",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "This parameter represents the state of the currently checked facet options. This parameter should be provided as a URL-encoded string containing a JSON object.\n\nThe JSON object contains a key for each facet category that has a checked facet option.  The value for each of these keys is an array of Filter objects that describe the filter that is applied by the facet option.\n\nAt the moment, facet options only support `$eq`.\n\nFor example, if `Engineering` was checked under the `Category` facet and `Chicago` and `New York` are checked under the `Job Location` facet, the `facetFilters` would look like:\n```\n{\n  \"c_jobCategory\": [\n    {\n      \"c_jobCategory\": {\n        \"$eq\": \"Engineering\"\n      }\n    }\n  ],\n  \"c_jobLocation\": [\n    {\n      \"c_jobLocation\": {\n        \"$eq\": \"Chicago\"\n      }\n    },\n    {\n      \"c_jobLocation\": {\n        \"$eq\": \"New York\"\n      }\n    }\n  ]\n}\n```\n"
      },
      "retrieveFacets": {
        "name": "retrieveFacets",
        "in": "query",
        "required": false,
        "schema": {
          "type": "boolean"
        },
        "description": "Whether facets should be computed for this vertical query."
      },
      "SortBys": {
        "name": "sortBys",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "This parameter overrides the sort options that are configured on the experience configuration.  This parameter should be provided as a URL-encoded string containing a JSON array.\n\nThe input is a JSON array containing each of the sort options in the order in which they should be applied.\n\nEach sort options must contain a `type`\n\n<table style=\"width:100%\">\n  <tr>\n    <th>Type</th>\n    <th>Details</th>\n  </tr>\n  <tr>\n    <th>RELEVANCE</th>\n    <th>Sorts based on relevance according to the algorithm and, when relevant, location bias</th>\n  </tr>\n  <tr>\n    <th>ENTITY_DISTANCE</th>\n    <th>Sorts based on entity distance alone</th>\n  </tr>\n  <tr>\n    <th>FIELD</th>\n    <th>sorts based on a field with the direction specified</th>\n  </tr>\n</table>\n\n</br>\n\nIf the `type` is `FIELD` the sort options must also specify `field` which is the api name of the field to sort on.\n\nFinally, if the `type` is `FIELD` the sort options must also specify the `direction`.\n\n<table style=\"width:100%\">\n  <tr>\n    <th>Direction</th>\n    <th>Details</th>\n  </tr>\n  <tr>\n    <th>ASC</th>\n    <th>Sorts in ascending order.  For numbers this is low to high. For text this is alphabetical.  For dates this is chronological order.</th>\n  </tr>\n  <tr>\n    <th>DESC</th>\n    <th>Sorts in ascending order.  For numbers this is high to low. For text this is reverse alphabetical.  For dates this is reverse chronological order.</th>\n  </tr>\n</table>\n\n</br>\n\n**Examples**\n```\n[\n  {\n    \"type\": \"FIELD\",\n    \"direction\": \"ASC\",\n    \"field\": \"startDate\"\n  },\n  {\n    \"type\": \"RELEVANCE\",\n    \"direction\": \"ASC\"\n  }\n]\n```\n"
      },
      "filterSearchVerticalKey": {
        "name": "verticalKey",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "String key that uniquely identifies the vertical to scope the filter search request to."
      },
      "excluded": {
        "name": "excluded",
        "in": "query",
        "required": false,
        "schema": {
          "type": "string"
        },
        "description": "JSON array containing the IDs of all filters that should be excluded from filter search results (if it has already been returned and selected). This parameter should be provided as a URL-encoded string containing a JSON array."
      },
      "SearchParameters": {
        "name": "search_parameters",
        "in": "query",
        "required": true,
        "schema": {
          "type": "string"
        },
        "description": "This parameter represents the parameters that should be used for filter search. This parameter should be provided as a URL-encoded string containing a JSON object.\n\nFilter search uses the user's input string to find a set of existing filters that match the user's input query for the fields provided in the parameters.\n\nThe parameters are made up of a list of `FilterField` objects that have the following properties:\n\n<table style=\"width:100%\">\n  <tr>\n    <th>Property</th>\n    <th>Details</th>\n  </tr>\n  <tr>\n    <th>field</th>\n    <th>The api name of the field.</th>\n  </tr>\n  <tr>\n    <th>entityTypeId</th>\n    <th>The api name for the entity type the filter belongs to.</th>\n  </tr>\n  <tr>\n    <th>shouldFetchEntities</th>\n    <th>Optional boolean.  If true, entities matching each filter will be returned inline with the filter.</th>\n  </tr>\n</table>\n\n</br>\n\nAdditionally, there is an optional parameter `sectioned`.  If set to true, the matching filters will be returned in a separate section per field.  By default, they are all returned in the same section.\n"
      }
    },
    "responses": {
      "AutocompleteResponse": {
        "description": "Autocomplete Request Response",
        "content": {
          "application/json": {
            "schema": {
              "title": "AutocompleteResponse",
              "type": "object",
              "properties": {
                "input": {
                  "type": "object",
                  "properties": {
                    "value": {
                      "type": "string",
                      "description": "The exact user input that triggered the autocomplete.\n"
                    },
                    "queryIntents": {
                      "type": "array",
                      "description": "List of query intents that the input has been tagged with.\n",
                      "items": {
                        "type": "string",
                        "description": "Intent that was derived from the user's input.\n"
                      }
                    }
                  }
                },
                "results": {
                  "type": "array",
                  "description": "The list of autocomplete results computed from the user's input.\n",
                  "items": {
                    "type": "object",
                    "description": "An individual autocomplete match.\n",
                    "properties": {
                      "value": {
                        "type": "string",
                        "description": "The plain text version of the autocomplete result.\n"
                      },
                      "matchedSubstrings": {
                        "type": "array",
                        "description": "The list of matched substrings within the value to highlight.\n",
                        "items": {
                          "type": "object",
                          "description": "Highlight information for the string autocomplete value.\n",
                          "properties": {
                            "offsets": {
                              "type": "integer",
                              "description": "The zero indexed offset from the start of the value where the highlight starts.\n"
                            },
                            "length": {
                              "type": "integer",
                              "description": "The length of the highlight.\n"
                            }
                          }
                        }
                      },
                      "queryIntents": {
                        "type": "array",
                        "description": "List of query intents that the input has been tagged with.\n",
                        "items": {
                          "type": "string",
                          "description": "Intent that was derived from the user's input.\n"
                        }
                      },
                      "verticalKeys": {
                        "type": "array",
                        "description": "List of verticals that the autocomplete result is derived from. For results coming from universal search, this field will be blank.\n",
                        "items": {
                          "type": "string",
                          "description": "A single vertical represented in the autocomplete result.\n"
                        }
                      }
                    }
                  }
                }
              }
            },
            "example": {
              "meta": {
                "uuid": "4f72b877-e2d0-4de4-9324-b9cf2c03e1a0",
                "errors": []
              },
              "response": {
                "input": {
                  "value": "yex",
                  "queryIntents": []
                },
                "results": [
                  {
                    "value": "Yext Search Experience Cloud",
                    "matchedSubstrings": [
                      {
                        "offset": 0,
                        "length": 3
                      }
                    ]
                  },
                  {
                    "value": "Yext Answers",
                    "matchedSubstrings": [
                      {
                        "offset": 0,
                        "length": 3
                      }
                    ]
                  }
                ]
              }
            }
          }
        }
      },
      "ErrorResponse": {
        "description": "Error Response",
        "content": {
          "application/json": {
            "schema": {
              "title": "ErrorResponse",
              "type": "object",
              "properties": {
                "meta": {
                  "$ref": "#/components/schemas/ResponseMetaWithError"
                },
                "response": {
                  "type": "object"
                }
              }
            }
          }
        }
      },
      "UniversalQueryResponse": {
        "description": "Universal Query Response",
        "content": {
          "application/json": {
            "schema": {
              "title": "UniversalQueryResponse",
              "type": "object",
              "properties": {
                "meta": {
                  "$ref": "#/components/schemas/ResponseMeta"
                },
                "response": {
                  "type": "object",
                  "properties": {
                    "businessId": {
                      "$ref": "#/components/schemas/businessId"
                    },
                    "queryId": {
                      "$ref": "#/components/schemas/queryId"
                    },
                    "modules": {
                      "$ref": "#/components/schemas/Modules"
                    },
                    "failedVerticals": {
                      "$ref": "#/components/schemas/FailedVerticals"
                    },
                    "directAnswer": {
                      "$ref": "#/components/schemas/DirectAnswer"
                    },
                    "spellCheck": {
                      "$ref": "#/components/schemas/SpellCheck"
                    },
                    "locationBias": {
                      "$ref": "#/components/schemas/LocationBias"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "VerticalQueryResponse": {
        "description": "Vertical Query Response",
        "content": {
          "application/json": {
            "schema": {
              "title": "VerticalQueryResponse",
              "type": "object",
              "properties": {
                "meta": {
                  "$ref": "#/components/schemas/ResponseMeta"
                },
                "response": {
                  "type": "object",
                  "properties": {
                    "businessId": {
                      "$ref": "#/components/schemas/businessId"
                    },
                    "queryId": {
                      "$ref": "#/components/schemas/queryId"
                    },
                    "resultsCount": {
                      "$ref": "#/components/schemas/resultCount"
                    },
                    "results": {
                      "$ref": "#/components/schemas/Results"
                    },
                    "appliedQueryFilters": {
                      "$ref": "#/components/schemas/AppliedQueryFilters"
                    },
                    "facets": {
                      "type": "array",
                      "description": "Contextual facets that contain metadata about the facet as well as the full facet.",
                      "items": {
                        "$ref": "#/components/schemas/Facets"
                      }
                    },
                    "searchIntents": {
                      "$ref": "#/components/schemas/SearchIntents"
                    },
                    "source": {
                      "type": "string",
                      "description": "Identifier for the backend source of the response.",
                      "example": "KNOWLEDGE_MANAGER"
                    },
                    "directAnswer": {
                      "$ref": "#/components/schemas/DirectAnswer"
                    },
                    "alternativeVerticals": {
                      "type": "object",
                      "description": "Response information from running this query on other verticals.",
                      "properties": {
                        "modules": {
                          "$ref": "#/components/schemas/Modules"
                        },
                        "failedVerticals": {
                          "$ref": "#/components/schemas/FailedVerticals"
                        }
                      }
                    },
                    "spellCheck": {
                      "$ref": "#/components/schemas/SpellCheck"
                    },
                    "locationBias": {
                      "$ref": "#/components/schemas/LocationBias"
                    },
                    "allResultsForVertical": {
                      "type": "object",
                      "description": "All results for this vertical.",
                      "properties": {
                        "businessId": {
                          "$ref": "#/components/schemas/businessId"
                        },
                        "queryId": {
                          "$ref": "#/components/schemas/queryId"
                        },
                        "resultsCount": {
                          "$ref": "#/components/schemas/resultCount"
                        },
                        "results": {
                          "$ref": "#/components/schemas/Results"
                        },
                        "facets": {
                          "type": "array",
                          "description": "Contextual facets that contain metadata about the facet as well as the full facet.",
                          "items": {
                            "$ref": "#/components/schemas/Facets"
                          }
                        },
                        "searchIntents": {
                          "$ref": "#/components/schemas/SearchIntents"
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "FilterSearchResponse": {
        "description": "Filter Search Response",
        "content": {
          "application/json": {
            "schema": {
              "title": "FilterSearchResponse",
              "type": "object",
              "properties": {
                "meta": {
                  "$ref": "#/components/schemas/ResponseMeta"
                },
                "response": {
                  "type": "object",
                  "properties": {
                    "businessId": {
                      "$ref": "#/components/schemas/businessId"
                    },
                    "sections": {
                      "type": "array",
                      "description": "The set of field names being queried, and their respective results for the current query\n",
                      "items": {
                        "type": "object",
                        "properties": {
                          "label": {
                            "type": "string",
                            "description": "The display name of the field being queried, can be used in a UI to distinguish one section from another\n"
                          },
                          "results": {
                            "type": "array",
                            "description": "The set of matches for the current query\n",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string",
                                  "description": "The API name of a field with a match for the current query\n"
                                },
                                "value": {
                                  "type": "string",
                                  "description": "The display name of the field value with a match for the current query\n"
                                },
                                "filter": {
                                  "$ref": "#/components/schemas/filter"
                                },
                                "matchedSubstrings": {
                                  "type": "array",
                                  "description": "A set of offsets that represent the portion of the \"value\" that is a match for the current query\n",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "offset": {
                                        "type": "integer",
                                        "description": "In the \"value\", the number of characters between the beginning of the string and the start of the match for the current query\n"
                                      },
                                      "length": {
                                        "type": "integer",
                                        "description": "In the \"value\", the number of characters from the offset that represents the end of the match for the current query\n"
                                      }
                                    }
                                  }
                                },
                                "relatedItem": {
                                  "type": "object",
                                  "description": "If a unique entity returns for the current query, the full entity object\n"
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    "failedVerticals": {
                      "$ref": "#/components/schemas/FailedVerticals"
                    },
                    "queryId": {
                      "$ref": "#/components/schemas/queryId"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "schemas": {
      "ResponseMeta": {
        "type": "object",
        "properties": {
          "uuid": {
            "type": "string",
            "example": "4f72b877-e2d0-4de4-9324-b9cf2c03e1a0",
            "description": "Unique ID for this request / response."
          }
        }
      },
      "ResponseError": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "description": "Code that uniquely identifies the error or warning.\n"
          },
          "type": {
            "type": "string",
            "enum": [
              "FATAL_ERROR",
              "NON_FATAL_ERROR",
              "WARNING"
            ]
          },
          "message": {
            "type": "string",
            "description": "Message explaining the problem."
          }
        }
      },
      "ResponseMetaWithError": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ResponseMeta"
          },
          {
            "type": "object",
            "properties": {
              "errors": {
                "type": "array",
                "description": "List of errors and warnings.",
                "items": {
                  "$ref": "#/components/schemas/ResponseError"
                }
              }
            }
          }
        ]
      },
      "businessId": {
        "type": "integer",
        "description": "ID of the account associated with this Answers experience"
      },
      "queryId": {
        "type": "string",
        "description": "UUID for the query"
      },
      "verticalConfigId": {
        "type": "string",
        "description": "String key that uniquely identifies the vertical."
      },
      "resultCount": {
        "type": "integer",
        "description": "The number of entities within the vertical that are relevant to the user's query.\n"
      },
      "Entity": {
        "type": "object",
        "properties": {
          "data": {
            "type": "object",
            "description": "The data containing the main content of the entity. The format of the data is dependent on the entity type.\n"
          },
          "highlightedFields": {
            "type": "object",
            "description": "A map from fieldId to highlighted element.\n"
          },
          "distance": {
            "type": "integer",
            "description": "The distance in meters between the entity and the query's location bias.\n"
          },
          "distanceFromFilter": {
            "type": "integer",
            "description": "The distance in meters between the entity and the filter applied to the query.\n"
          }
        }
      },
      "Results": {
        "type": "array",
        "description": "The individual entity results that contain metadata about the entity as well as the fully rendered profiles.\n",
        "items": {
          "$ref": "#/components/schemas/Entity"
        }
      },
      "filter": {
        "type": "object",
        "description": "The filter, in the filter format, that was applied.\n<br><br>\nFor example: `\"c_exampleFieldId\": { $eq\": \"Answers\" }`\n",
        "example": "c_exampleFieldId: { $eq\": \"Answers\" }\n"
      },
      "AppliedQueryFilters": {
        "type": "array",
        "description": "A list of the filters that were inferred from the user's query and applied at search time.",
        "items": {
          "type": "object",
          "properties": {
            "displayKey": {
              "type": "string",
              "description": "The display name of the field to which the filter belongs."
            },
            "displayValue": {
              "type": "string",
              "description": "The value of the filter."
            },
            "filter": {
              "$ref": "#/components/schemas/filter"
            },
            "type": {
              "type": "string",
              "enum": [
                "FIELD_VALUE",
                "PLACE",
                "INTENT"
              ]
            },
            "details": {
              "type": "object",
              "description": "Object containing additional details relevant to the filter such as additional details about the place for `PLACE` type filters. The format of the data is dependent on the filter type.\n"
            }
          }
        }
      },
      "Module": {
        "type": "object",
        "description": "The results and metadata pertaining to a single vertical relevant to the user's query.",
        "properties": {
          "verticalConfigId": {
            "$ref": "#/components/schemas/verticalConfigId"
          },
          "resultCount": {
            "$ref": "#/components/schemas/resultCount"
          },
          "encodedState": {
            "type": "string",
            "description": "Deprecated."
          },
          "results": {
            "$ref": "#/components/schemas/Results"
          },
          "appliedQueryFilters": {
            "$ref": "#/components/schemas/AppliedQueryFilters"
          }
        }
      },
      "Modules": {
        "type": "array",
        "description": "List of results for each vertical that was relevant to the query, returned in the order of relevance.",
        "items": {
          "$ref": "#/components/schemas/Module"
        }
      },
      "FailedVertical": {
        "type": "object",
        "properties": {
          "verticalConfigId": {
            "$ref": "#/components/schemas/verticalConfigId"
          },
          "errorType": {
            "type": "string",
            "description": "An identifier for the type of error causing the failure.\n",
            "enum": [
              "TIMEOUT",
              "BACKEND_ERROR",
              "INVALID_CONFIG",
              "INVALID_QUERY"
            ]
          },
          "details": {
            "type": "object",
            "properties": {
              "responseCode": {
                "type": "integer",
                "description": "An HTTP response status code indicating the completion status of the request.\n"
              },
              "description": {
                "type": "string",
                "description": "Message explaining the error."
              }
            }
          },
          "queryDurationMillis": {
            "type": "integer",
            "description": "A measure of query duration, recorded in milliseconds.\n"
          }
        }
      },
      "FailedVerticals": {
        "type": "array",
        "description": "Contains error information when one or more verticals fail to return results.\n",
        "items": {
          "$ref": "#/components/schemas/FailedVertical"
        }
      },
      "DirectAnswer": {
        "type": "object",
        "description": "Information that is estimated to directly answer the question of the query.\n",
        "properties": {
          "type": {
            "type": "string",
            "description": "Type of the direct answer, such as `FIELD_VALUE` or `FEATURED_SNIPPET`.\n"
          },
          "answer": {
            "type": "object",
            "description": "The data containing the main content of the direct answer. The format of the data is dependent on the direct answer type.\n"
          },
          "relatedItem": {
            "type": "object",
            "description": "An optional item that is related to the direct answer. For Knowledge Manager verticals, related items will typically be entities.\n",
            "properties": {
              "verticalConfigId": {
                "$ref": "#/components/schemas/verticalConfigId"
              },
              "data": {
                "type": "object",
                "description": "The data of the related item, which should be in the same shape (with possibly extra fields) as an item that appears in a section of results from the same vertical in universal search.\n"
              }
            }
          }
        }
      },
      "HighlightedValue": {
        "type": "object",
        "description": "Highlighting instructions for a field value, containing the original value of the field and all sections of the value that should be highlighted.\n",
        "properties": {
          "value": {
            "type": "string",
            "description": "The original value of the field.\n"
          },
          "matchedSubstrings": {
            "type": "array",
            "description": "The list of matched substrings within the value to highlight.\n",
            "items": {
              "type": "object",
              "description": "Highlight information for the string autocomplete value.\n",
              "properties": {
                "offsets": {
                  "type": "integer",
                  "description": "The zero indexed offset from the start of the value where the highlight starts.\n"
                },
                "length": {
                  "type": "integer",
                  "description": "The length of the highlight.\n"
                }
              }
            }
          }
        }
      },
      "SpellCheck": {
        "type": "object",
        "description": "SpellCheck information that may correct the user's query.",
        "properties": {
          "originalQuery": {
            "type": "string",
            "description": "The unedited, original query from the request."
          },
          "correctedQuery": {
            "$ref": "#/components/schemas/HighlightedValue"
          },
          "type": {
            "type": "string",
            "description": "The type of SpellCheck suggestion.\n<br><br>\n`SUGGEST` is often used for \"Did you mean...\"\n<br>\n`AUTOCORRECT` is often used for \"Showing results for ... instead of ...\"\n<br>\n`COMBINE` is often used for \"Including results for ...\"\n<br><br>\n",
            "enum": [
              "SUGGEST",
              "AUTOCORRECT",
              "COMBINE"
            ]
          }
        }
      },
      "LocationBias": {
        "type": "object",
        "description": "Information about geographical location biases used in the search.",
        "properties": {
          "latitude": {
            "type": "number",
            "description": "The geographic coordinate, latitude, used to bias the search.",
            "example": 41.7828
          },
          "longitude": {
            "type": "number",
            "description": "The geographic coordinate, latitude, used to bias the search.",
            "example": -87.8781
          },
          "locationDisplayName": {
            "type": "string",
            "description": "The display name of the location.",
            "example": "Countryside, Illinois, United States"
          },
          "accuracy": {
            "type": "string",
            "description": "The accuracy of the location bias used for the search.\n<br><br>\n`DEVICE` is based on the user's device (passed in via the request param)\n<br>\n`IP` is based on the request's IP\n<br>\n",
            "enum": [
              "IP",
              "DEVICE",
              "UNKNOWN"
            ]
          }
        }
      },
      "Facets": {
        "type": "object",
        "properties": {
          "fieldId": {
            "type": "string",
            "description": "The field identifier for the field being searched."
          },
          "displayName": {
            "type": "string",
            "description": "The display name for the field being searched."
          },
          "options": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "displayName": {
                  "type": "string",
                  "description": "The display name for the Facet option."
                },
                "count": {
                  "type": "integer",
                  "description": "The number of entities within the vertical that are relevant to this Facet option."
                },
                "isSelected": {
                  "type": "boolean",
                  "description": "A boolean indicator of whether this Facet option was used to filter results in the response."
                },
                "filter": {
                  "$ref": "#/components/schemas/filter"
                }
              }
            }
          }
        }
      },
      "SearchIntents": {
        "type": "array",
        "description": "Items in array each represent a particular intent expressed in the user's query. Example: `NEAR_ME`\n",
        "items": {
          "type": "string"
        }
      }
    }
  },
  "security": [
    {
      "api_key": []
    },
    {
      "api-key": []
    }
  ],
  "tags": [
    {
      "name": "Answers API"
    }
  ]
}